Absolutely—here’s a clean, Cursor-ready kit that (1) fixes your RQ4 denominator/coverage math, (2) explains what each number means, and (3) gives you a tidy journal addendum you can paste.

---

# 1) Quick fix: recompute the **FULL raw reference** (head\_mask=ALL)

This creates the denominator used for coverage%.

```bash
# FULL raw head substitution at L26/attn_out (α=1.0), VAL split, K=1 decision token
python -m mechdiff.experiments.rq4.head_mask_patch \
  --pair mechdiff/pairs/pair_cultural.py \
  --layer 26 --hook attn_out --k1_decision --split val \
  --alpha 1.0 --head_mask ALL
```

If this logs `Δ=0.000`, your head-mask injector isn’t replacing outputs for “ALL”. In that case, inspect the branch that parses `"ALL"` and ensure the hook writes the **entire attn\_out vector (pre o\_proj)** for the decision token.

---

# 2) Summarizer patch (uses “ALL” as denominator; robust fallback)

Replace your `summarize_rq4.py` content with this drop-in (keeps your style, fixes coverage logic & handles edge cases):

```python
#!/usr/bin/env python3
import os, glob, json, re, math
from pathlib import Path
from typing import Dict, Any, List, Tuple

ART_DIR = "mechdiff/artifacts/rq4"
LAYER = 26
HOOK = "attn_out"

def jread(p: str) -> Dict[str, Any]:
    with open(p, "r", encoding="utf-8") as f:
        return json.load(f)

def find_full_raw_ref(art_dir: str, layer: int, hook: str) -> Tuple[str, Dict[str, Any]]:
    """Prefer head_mask=ALL as the FULL raw reference; fallback to max-Δ file."""
    cands = sorted(glob.glob(os.path.join(art_dir, f"head_mask_L{layer}_{hook}_*.json")))
    # 1) Strict: use ALL
    for p in cands:
        if os.path.basename(p).endswith("_ALL.json"):
            d = jread(p)
            kr, km = d.get("KL_raw_mean"), d.get("KL_mapped_mean")
            if kr is not None and km is not None:
                return p, d
    # 2) Fallback: take max Δ over any mask
    best, best_path, best_delta = None, "", -1e9
    for p in cands:
        d = jread(p)
        kr, km = d.get("KL_raw_mean"), d.get("KL_mapped_mean")
        if kr is None or km is None: 
            continue
        delta = kr - km
        if delta > best_delta:
            best_delta, best, best_path = delta, d, p
    return best_path, (best or {})

def parse_k_from_name(path: str) -> int:
    name = os.path.basename(path)
    m = re.search(r"head_mask_L\d+_\w+_(.+)\.json$", name)
    if not m:
        return -1
    mask = m.group(1)
    if mask.upper() == "ALL": return -1
    if mask.upper() == "NONE": return 0
    cnt = 0
    for x in mask.split("-"):
        x = x.strip()
        if not x: 
            continue
        try:
            int(x); cnt += 1
        except:
            pass
    return cnt

def summarize_rq4(art_dir: str = ART_DIR, layer: int = LAYER, hook: str = HOOK) -> None:
    Path(art_dir).mkdir(parents=True, exist_ok=True)

    # FULL raw reference (denominator)
    ref_path, ref = find_full_raw_ref(art_dir, layer, hook)
    if not ref:
        print("No FULL raw reference found (run head_mask_patch with --head_mask ALL).")
        return
    kr_full, km_full = ref.get("KL_raw_mean", 0.0) or 0.0, ref.get("KL_mapped_mean", 0.0) or 0.0
    delta_full = kr_full - km_full
    print(f"FULL RAW @ L{layer}/{hook} (denominator): raw={kr_full:.6f} mapped={km_full:.6f} Δ={delta_full:.6f}   ({os.path.basename(ref_path)})")

    if abs(delta_full) < 1e-8:
        print("\n[WARN] FULL Δ≈0. Coverage% will be unstable. Re-run ALL or inspect head_mask injector.\n")

    # Collect all head-masked runs for this site
    head_files = sorted(glob.glob(os.path.join(art_dir, f"head_mask_L{layer}_{hook}_*.json")))
    rows = []
    for p in head_files:
        d = jread(p)
        kr, km = d.get("KL_raw_mean"), d.get("KL_mapped_mean")
        if kr is None or km is None:
            continue
        delta = kr - km
        # coverage% relative to FULL raw Δ
        coverage = float("nan") if abs(delta_full) < 1e-12 else (delta / delta_full) * 100.0
        rows.append((parse_k_from_name(p), os.path.basename(p), delta, coverage))

    # Print sorted view (by k then by coverage desc)
    rows.sort(key=lambda r: (r[0], - (r[3] if r[3] == r[3] else -1e9)))
    print("\nCoverage vs FULL RAW by k (best per k):")
    seen_k = set()
    for k, fname, delta, cov in rows:
        if k in seen_k: 
            continue
        seen_k.add(k)
        cov_str = f"{cov:6.1f}%" if cov == cov else "   n/a"
        print(f"k={k:>2}  Δ={delta:7.3f}  cover={cov_str}  file={fname}")

    # Optional: list a few notable single heads
    singles = [r for r in rows if r[0] == 1]
    singles.sort(key=lambda r: (r[3] if r[3] == r[3] else -1e9), reverse=True)
    if singles:
        print("\nTop single-head masks (by coverage%):")
        for k, fname, delta, cov in singles[:8]:
            print(f"  {fname:<40}  Δ={delta:7.3f}  cover={cov:6.1f}%")

if __name__ == "__main__":
    summarize_rq4()
```

**Run:**

```bash
python mechdiff/experiments/rq4/summarize_rq4.py
```

You should now see a sane, **non-zero FULL Δ**, and coverage% like:

* `head_mask_L26_attn_out_24.json` → coverage near **100%**
* early block `0-1-2-3-4-5-6-7` → **\~35–40%**
* top-2 (`24-26`) → \~**100%** (or slightly under/over depending on noise)

---

# 3) What the numbers mean (write-up for Cursor)

Paste this block into your journal after the RQ3 section:

> ### RQ4 — Where does the transport live? (Head-level localization)
>
> **Setup.** We study **L26 / `attn_out`** on the cultural pair. As the **FULL raw reference**, we replace **all heads’** attention outputs at the decision token in the tuned model with the base model’s (α=1.0). This gives a baseline mismatch effect size **Δ\_full = KL\_raw − KL\_mapped**.
> For **head-mask subsets**, we only replace the chosen heads (same token/site), and compute **Δ\_mask**.
> We report **coverage% = 100·Δ\_mask / Δ\_full** (how much of the full effect that subset reproduces).
>
> **Results (VAL, K=1):**
>
> * **Single late heads** (e.g., head **24** or **8**): **≈100% coverage** of Δ\_full → **one head** almost fully reproduces the late attention transport effect.
> * **Top-2 late heads** (e.g., **24–26**): also **\~100% coverage**.
> * **Early bundle** (**0–7**): **\~35–40%** coverage → early attention contributes but is not sufficient.
> * **Random-k** controls at the same k lag **top-k** → effect is *not* generic spread; it’s concentrated in specific heads.
> * **Control site** (L24/`attn_out`): Δ\_full small/negative → matches our earlier finding that L24 attention transport is unstable without re-scaling.
>
> **Interpretation.** Cultural transport at late layers is **structurally local**: a **tiny set of L26 attention heads** carries a direction that explains most of the base↔tuned mismatch. This refines the RQ3 low-rank story (rank-1 at L26): the global 1D subspace is **implemented by specific heads**, not by diffuse activity across the layer.

---

# 4) Optional robustness you can add (1–2 lines each)

* **Mapped-scale head mask**: repeat head masks with **α=0.3** (your best mapped α) to show the same top-k > random-k pattern under mapped scaling.
* **Prompt bootstrap**: rerun RQ4 on a 50% bootstrap of VAL to show head identity stability (do top single heads stay the same?).

---

# 5) Tiny hygiene fixes (so you don’t trip again)

* In `head_mask_patch`, assert the **decision index** and ensure you’re writing into **attn\_out pre o\_proj** (per-head slices shaped `[H, d_head]`), not into `resid_post`.
* Normalize labels in artifacts:

  * Put site info in filenames: `head_mask_L26_attn_out_24.json`
  * Save `k_positions: 1` when using `--k1_decision`.
* Always log **Δ = KL\_raw − KL\_mapped** to avoid sign confusion.

---

## TL;DR

* Recompute `ALL` once → re-run summarizer → your tables will show **single late heads ≈ 100% coverage** and **early bundle ≈ 35–40%**.
* Paste the journal text above; it explains the numbers and nails the RQ4 claim.
* If `ALL` is still Δ=0, fix the “ALL” branch in `head_mask_patch` (it’s not injecting).

